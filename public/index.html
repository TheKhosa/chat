<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Chat</title>
    <script src="/socket.io/socket.io.js"></script>
    <!-- Replaced emoji-js with Twemoji for better emoji rendering and support -->
    <script src="https://cdn.jsdelivr.net/npm/twemoji@latest/dist/twemoji.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background: #1a1a1a; color: #e5e5e5; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        .container { width: 100%; height: 100vh; background: #1a1a1a; display: flex; flex-direction: column; border: none; }
        .header { background: #0a0a0a; color: #e5e5e5; padding: 12px 16px; border-bottom: 1px solid #2c2c2c; display: flex; align-items: center; justify-content: space-between; min-height: 50px; }
        .header h1 { font-size: 1rem; font-weight: 600; color: #e5e5e5; }
        .channel-info { background: #0f0f0f; padding: 8px 16px; border-bottom: 1px solid #2c2c2c; font-size: 12px; color: #8a8a8a; display: flex; justify-content: space-between; align-items: center; }
        .username-setup { background: #0f0f0f; padding: 12px 16px; border-bottom: 1px solid #2c2c2c; display: none; }
        .username-setup.show { display: flex; align-items: center; gap: 8px; }
        .username-setup input { flex: 1; padding: 6px 8px; border: 1px solid #2c2c2c; border-radius: 4px; background: #1a1a1a; color: #e5e5e5; font-size: 12px; }
        .username-setup input:focus { outline: none; border-color: #c02b2b; }
        .username-setup button { background: #c02b2b; color: white; padding: 6px 12px; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; transition: background 0.2s; }
        .username-setup button:hover { background: #e04141; }
        .chat-container { display: flex; flex: 1; flex-direction: column; overflow: hidden; }
        .messages { flex: 1; overflow-y: auto; padding: 8px; background: #1a1a1a; scrollbar-width: thin; scrollbar-color: #2c2c2c #1a1a1a; }
        .messages::-webkit-scrollbar { width: 6px; }
        .messages::-webkit-scrollbar-track { background: #1a1a1a; }
        .messages::-webkit-scrollbar-thumb { background: #2c2c2c; border-radius: 3px; }
        .message { margin-bottom: 8px; padding: 6px 8px; border-radius: 4px; background: rgba(255, 255, 255, 0.03); font-size: 13px; line-height: 1.4; word-wrap: break-word; cursor: pointer; transition: background 0.2s; position: relative; }
        .message:hover { background: rgba(255, 255, 255, 0.06); }
        .message.system { background: rgba(192, 43, 43, 0.1); color: #ff6b6b; font-style: italic; text-align: center; font-size: 12px; cursor: default; }
        .message.system:hover { background: rgba(192, 43, 43, 0.1); }
        .message.reply { background: rgba(192, 43, 43, 0.08); border-left: 3px solid #c02b2b; }
        .message-header { font-weight: 600; margin-bottom: 2px; font-size: 12px; display: flex; align-items: center; gap: 6px; }
        .message-username { cursor: pointer; }
        .message-username:hover { text-decoration: underline; }
        .message-time { font-size: 10px; color: #666; margin-left: auto; }
        .reply-indicator { background: rgba(192, 43, 43, 0.2); color: #ff8a8a; font-size: 10px; padding: 2px 6px; border-radius: 3px; margin-bottom: 4px; border-left: 2px solid #c02b2b; }
        .message-content { color: #e5e5e5; line-height: 1.4; }
        .typing-indicator { padding: 6px 16px; font-style: italic; color: #8a8a8a; font-size: 11px; min-height: 24px; background: #0f0f0f; border-top: 1px solid #2c2c2c; }
        .message-form { 
            display: flex; 
            padding: 8px; 
            background: #0f0f0f; 
            border-top: 1px solid #2c2c2c; 
            gap: 8px; 
            flex-direction: column; 
            position: relative; /* This anchors the absolute-positioned emote picker. */
        }
        .reply-preview { background: rgba(192, 43, 43, 0.1); border-left: 3px solid #c02b2b; padding: 6px 8px; font-size: 11px; color: #ccc; margin-bottom: 8px; border-radius: 3px; display: none; position: relative; }
        .reply-preview .cancel-reply { position: absolute; top: 4px; right: 6px; background: none; border: none; color: #999; cursor: pointer; font-size: 14px; padding: 0; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; }
        .reply-preview .cancel-reply:hover { color: #fff; }
        .message-input-row { display: flex; gap: 8px; }
        .message-input { flex: 1; padding: 8px; border: 1px solid #2c2c2c; border-radius: 4px; font-size: 13px; background: #1a1a1a; color: #e5e5e5; }
        .message-input:focus { outline: none; border-color: #c02b2b; }
        .emote-btn { background: #2c2c2c; color: #e5e5e5; padding: 8px 10px; border: none; border-radius: 4px; cursor: pointer; transition: background 0.2s; font-size: 12px; }
        .emote-btn:hover { background: #3c3c3c; }
        .send-btn { background: #c02b2b; color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; transition: background 0.2s; font-size: 12px; }
        .send-btn:hover { background: #e04141; }
        .emote-picker { position: absolute; bottom: 100%; right: 8px; background: #0f0f0f; border: 1px solid #2c2c2c; border-radius: 6px; display: none; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); width: 380px; max-height: 400px; overflow-y: auto; margin-bottom: 8px; }
        .emote-picker.show { display: block; }
        .emote-tabs { display: flex; border-bottom: 1px solid #2c2c2c; background: #0a0a0a; }
        .emote-tab { flex: 1; padding: 8px 12px; background: none; border: none; color: #8a8a8a; cursor: pointer; font-size: 11px; transition: all 0.2s; }
        .emote-tab.active { color: #c02b2b; background: #1a1a1a; }
        .emote-tab:hover { background: rgba(255, 255, 255, 0.05); }
        .emote-content { padding: 8px; max-height: 340px; overflow-y: auto; }
        .emote-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; }
        .emote-item { background: none; border: none; padding: 6px; border-radius: 4px; cursor: pointer; font-size: 18px; transition: background 0.2s; display: flex; align-items: center; justify-content: center; min-height: 32px; position: relative; }
        .emote-item:hover { background: rgba(255, 255, 255, 0.1); }
        .emote-item img { width: 24px; height: 24px; object-fit: contain; }
        .emote-item .ffz-emote { width: 28px; height: 28px; object-fit: contain; }
        .emote-item:hover::after { content: attr(title); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: #000; color: #fff; padding: 4px 8px; border-radius: 4px; font-size: 10px; white-space: nowrap; z-index: 1001; }
        .error { color: #ff6b6b; background: rgba(255, 107, 107, 0.1); padding: 8px; border-radius: 4px; margin: 8px; text-align: center; font-size: 12px; }
        body::-webkit-scrollbar { display: none; }
        body { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* User Color Classes */
        .user-red { color: #ff6b6b !important; } .user-orange { color: #ffa726 !important; } .user-yellow { color: #ffeb3b !important; } .user-green { color: #66bb6a !important; } .user-blue { color: #42a5f5 !important; } .user-purple { color: #ab47bc !important; } .user-pink { color: #ec407a !important; } .user-cyan { color: #26c6da !important; } .user-lime { color: #9ccc65 !important; } .user-indigo { color: #5c6bc0 !important; } .user-teal { color: #26a69a !important; } .user-amber { color: #ffca28 !important; }
        
        /* Emote styling in messages */
        .emote { height: 1.5em; width: 1.5em; vertical-align: middle; margin: 0 2px; }
        .custom-emote { height: 24px; vertical-align: middle; margin: 0 2px; }
        .gif-emote { height: 32px; vertical-align: middle; margin: 0 2px; }
        .ffz-emote-inline { height: 28px; vertical-align: middle; margin: 0 2px; }

        /* Loading indicator */
        .loading { color: #8a8a8a; font-style: italic; text-align: center; padding: 8px; }
        
        /* FFZ emote search */
        .emote-search { width: 100%; padding: 6px 8px; margin-bottom: 8px; border: 1px solid #2c2c2c; border-radius: 4px; background: #1a1a1a; color: #e5e5e5; font-size: 11px; }
        .emote-search:focus { outline: none; border-color: #c02b2b; }
        
        .ffz-header { padding: 4px 8px; background: #0a0a0a; border-bottom: 1px solid #2c2c2c; font-size: 10px; color: #8a8a8a; display: flex; justify-content: space-between; align-items: center; }
        .ffz-load-more { background: #2c2c2c; color: #e5e5e5; padding: 4px 8px; border: none; border-radius: 3px; cursor: pointer; font-size: 10px; margin-top: 8px; }
        .ffz-load-more:hover { background: #3c3c3c; }
    </style>
</head>
<body>
    <div class="container">
        <div id="usernameSetup" class="username-setup">
            <input type="text" id="usernameInput" placeholder="Enter your username..." maxlength="20">
            <button id="setUsernameBtn">Set Username</button>
        </div>
        <div id="errorContainer"></div>
        <div id="chatContainer" class="chat-container" style="display: none;">
            <div class="channel-info">
                <div id="channelName"></div>
                <div id="userCount"></div>
            </div>
            <div id="messages" class="messages"></div>
            <div id="typingIndicator" class="typing-indicator"></div>
            <form id="messageForm" class="message-form">
                <div id="replyPreview" class="reply-preview">
                    <button type="button" class="cancel-reply" id="cancelReply">×</button>
                    <div id="replyContent"></div>
                </div>
                <div class="message-input-row">
                    <input type="text" id="messageInput" class="message-input" placeholder="Type your message..." maxlength="500" required>
                    <button type="button" id="emoteBtn" class="emote-btn">😀</button>
                    <button type="submit" class="send-btn">Send</button>
                </div>
                <div id="emotePicker" class="emote-picker">
                    <div class="emote-tabs">
                        <button class="emote-tab active" data-tab="emoji">😀 Emoji</button>
                        <button class="emote-tab" data-tab="ffz">🐸 FFZ</button>
                    </div>
                    <div class="emote-content">
                        <div id="emojiGrid" class="emote-grid"></div>
                        <div id="ffzGrid" style="display: none;">
                            <div class="ffz-header">
                                <span>FrankerFaceZ Emotes</span>
                                <span id="ffzStatus">Ready</span>
                            </div>
                            <input type="text" id="ffzSearch" class="emote-search" placeholder="Search FFZ emotes...">
                            <div id="ffzEmoteGrid" class="emote-grid"></div>
                            <button id="ffzLoadMore" class="ffz-load-more" style="display: none;">Load More</button>
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </div>
    <script>
        var socket = io();
        var currentUser = null;
        var currentChannel = null;
        var typingTimer = null;
        var currentReply = null;
        var userColors = {};
        
        // DOM elements
        var channelName = document.getElementById('channelName');
        var userCount = document.getElementById('userCount');
        var usernameSetup = document.getElementById('usernameSetup');
        var usernameInput = document.getElementById('usernameInput');
        var setUsernameBtn = document.getElementById('setUsernameBtn');
        var chatContainer = document.getElementById('chatContainer');
        var messages = document.getElementById('messages');
        var messageForm = document.getElementById('messageForm');
        var messageInput = document.getElementById('messageInput');
        var typingIndicator = document.getElementById('typingIndicator');
        var errorContainer = document.getElementById('errorContainer');
        var emoteBtn = document.getElementById('emoteBtn');
        var emotePicker = document.getElementById('emotePicker');
        var emoteGrid = document.getElementById('emojiGrid');
        var ffzGrid = document.getElementById('ffzGrid');
        var ffzEmoteGrid = document.getElementById('ffzEmoteGrid');
        var ffzSearch = document.getElementById('ffzSearch');
        var ffzLoadMore = document.getElementById('ffzLoadMore');
        var ffzStatus = document.getElementById('ffzStatus');
        var replyPreview = document.getElementById('replyPreview');
        var replyContent = document.getElementById('replyContent');
        var cancelReply = document.getElementById('cancelReply');
        
        // Emote storage
        var ffzEmotes = {};
        var ffzPage = 1;
        var ffzSearchTerm = '';
        var ffzLoading = false;
        
        // Popular FFZ emotes (fallback if API isn't available)
        var popularFFZEmotes = {
            'OMEGALUL': 'https://cdn.frankerfacez.com/emoticon/128054/1',
            'Pog': 'https://cdn.frankerfacez.com/emoticon/210748/1',
            'PepeHands': 'https://cdn.frankerfacez.com/emoticon/59765/1',
            'widepeepoHappy': 'https://cdn.frankerfacez.com/emoticon/270930/1',
            'LULW': 'https://cdn.frankerfacez.com/emoticon/134240/1',
            'Pepega': 'https://cdn.frankerfacez.com/emoticon/243789/1',
            'KEKW': 'https://cdn.frankerfacez.com/emoticon/381875/1',
            'monkaW': 'https://cdn.frankerfacez.com/emoticon/229486/1',
            '5Head': 'https://cdn.frankerfacez.com/emoticon/274406/1',
            'POGGERS': 'https://cdn.frankerfacez.com/emoticon/214129/1',
            'monkaS': 'https://cdn.frankerfacez.com/emoticon/130762/1',
            'AYAYA': 'https://cdn.frankerfacez.com/emoticon/162146/1',
            'PepeLaugh': 'https://cdn.frankerfacez.com/emoticon/263056/1',
            'widepeepoSad': 'https://cdn.frankerfacez.com/emoticon/270929/1',
            'Sadge': 'https://cdn.frankerfacez.com/emoticon/425618/1',
            'FeelsBadMan': 'https://cdn.frankerfacez.com/emoticon/1001/1',
            'HYPERS': 'https://cdn.frankerfacez.com/emoticon/154484/1',
            'YEP': 'https://cdn.frankerfacez.com/emoticon/280648/1',
            'FeelsOkayMan': 'https://cdn.frankerfacez.com/emoticon/145916/1',
            'Kapp': 'https://cdn.frankerfacez.com/emoticon/240748/1'
        };
        
        // Basic emoji collection
        var basicEmojis = [
            '😀', '😃', '😄', '😁', '😆', '😅', '🤣', '😂', '🙂', '🙃',
            '😉', '😊', '😇', '🥰', '😍', '🤩', '😘', '😗', '☺️', '😚',
            '😙', '🥲', '😋', '😛', '😜', '🤪', '😝', '🤑', '🤗', '🤭',
            '🤫', '🤔', '🤐', '🤨', '😐', '😑', '😶', '😏', '😒', '🙄',
            '😬', '🤥', '😔', '😪', '🤤', '😴', '😷', '🤒', '🤕', '🤢',
            '🤮', '🤧', '🥵', '🥶', '🥴', '😵', '🤯', '🤠', '🥳', '🥸',
            '😎', '🤓', '🧐', '😕', '😟', '🙁', '☹️', '😮', '😯', '😲',
            '😳', '🥺', '😦', '😧', '😨', '😰', '😥', '😢', '😭', '😱',
            '😖', '😣', '😞', '😓', '😩', '😫', '🥱', '😤', '😡', '😠',
            '🤬', '😈', '👿', '💀', '☠️', '💩', '🤡', '👹', '👺', '👻',
            '👽', '👾', '🤖', '🎃', '❤️', '🧡', '💛', '💚', '💙', '💜',
            '🖤', '🤍', '🤎', '💔', '❣️', '💕', '💞', '💓', '💗', '💖',
            '💘', '💝', '💟', '👍', '👎', '👌', '🤏', '✌️', '🤞', '🤟',
            '🤘', '🤙', '👈', '👉', '👆', '👇', '☝️', '👋', '🤚', '🖐️',
            '✋', '🖖', '👏', '🙌', '👐', '🤲', '🤝', '🙏', '✍️', '💪',
            '🔥', '💯', '💎', '⚡', '🌟', '✨', '🎉', '🎊', '🏆', '🎯'
        ];
        
        var currentTab = 'emoji';
        var isTyping = false;
        
        // User color classes
        const colorClasses = [
            'user-red', 'user-orange', 'user-yellow', 'user-green',
            'user-blue', 'user-purple', 'user-pink', 'user-cyan',
            'user-lime', 'user-indigo', 'user-teal', 'user-amber'
        ];
        
        function generateRandomUsername() {
            const adjectives = ['Happy', 'Cool', 'Swift', 'Bright', 'Silent', 'Bold'];
            const nouns = ['Viewer', 'User', 'Guest', 'Watcher', 'Fan', 'Friend'];
            const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            const number = Math.floor(Math.random() * 999) + 1;
            return `${adj}${noun}${number}`;
        }
        
        function getUserColor(username) {
            if (!userColors[username]) {
                let hash = 0;
                for (let i = 0; i < username.length; i++) {
                    hash = username.charCodeAt(i) + ((hash << 5) - hash);
                }
                userColors[username] = colorClasses[Math.abs(hash) % colorClasses.length];
            }
            return userColors[username];
        }

        // Load FFZ emotes with proxy endpoint or fallback
        async function loadFFZEmotes(search = '', page = 1, append = false) {
            if (ffzLoading) return;
            ffzLoading = true;
            ffzStatus.textContent = 'Loading...';
            
            try {
                // Build parameters for the API call
                const params = new URLSearchParams({
                    per_page: '40',
                    sort: 'count-desc',
                    page: page.toString()
                });
                
                if (search) {
                    params.append('q', search);
                }
                
                // Try the server's FFZ proxy endpoint first
                let response;
                try {
                    response = await fetch(`/api/ffz/emoticons?${params}`);
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('Loaded FFZ emotes from proxy:', data.emoticons.length);
                        
                        // Convert API response to our format
                        const emoteMap = {};
                        data.emoticons.forEach(emote => {
                            if (emote.imageUrl && emote.name) {
                                emoteMap[emote.name] = emote.imageUrl;
                                // Store in global FFZ emotes for message processing
                                ffzEmotes[emote.name] = emote.imageUrl;
                            }
                        });
                        
                        displayFFZEmotes(emoteMap, !append);
                        ffzStatus.textContent = `${data.emoticons.length} emotes loaded`;
                        
                        // Show load more button if there are more pages
                        if (data._pages && page < data._pages) {
                            ffzLoadMore.style.display = 'block';
                        } else {
                            ffzLoadMore.style.display = 'none';
                        }
                        
                        return; // Success, exit function
                    }
                } catch (proxyError) {
                    console.warn('Proxy endpoint failed:', proxyError.message);
                }
                
                // Fallback to popular emotes if proxy fails
                if (page === 1 && !search) {
                    console.log('Using fallback popular emotes');
                    displayFFZEmotes(popularFFZEmotes, !append);
                    ffzStatus.textContent = `${Object.keys(popularFFZEmotes).length} popular emotes (fallback)`;
                    ffzLoadMore.style.display = 'none';
                    
                    // Add popular emotes to global collection
                    Object.assign(ffzEmotes, popularFFZEmotes);
                } else {
                    ffzStatus.textContent = 'Proxy needed for search/pagination';
                    if (!append) {
                        ffzEmoteGrid.innerHTML = '<div class="loading">Server proxy required for full FFZ integration</div>';
                    }
                }
                
            } catch (error) {
                console.error('Failed to load FFZ emotes:', error);
                if (page === 1 && !search) {
                    // Fallback to popular emotes
                    displayFFZEmotes(popularFFZEmotes, !append);
                    ffzStatus.textContent = 'Using popular emotes (error fallback)';
                    Object.assign(ffzEmotes, popularFFZEmotes);
                } else {
                    showError('Failed to load FFZ emotes. Using cached emotes.');
                    ffzStatus.textContent = 'Error loading';
                }
                ffzLoadMore.style.display = 'none';
            } finally {
                ffzLoading = false;
            }
        }
        
        function displayFFZEmotes(emotes, clear = true) {
            if (clear) {
                ffzEmoteGrid.innerHTML = '';
            }
            
            Object.entries(emotes).forEach(([name, url]) => {
                const emoteElement = document.createElement('button');
                emoteElement.className = 'emote-item';
                emoteElement.title = name;
                
                // Add better error handling and URL validation
                const img = document.createElement('img');
                img.src = url;
                img.alt = name;
                img.className = 'ffz-emote';
                img.onerror = function() {
                    console.warn(`Failed to load FFZ emote: ${name} from ${url}`);
                    this.parentElement.style.display = 'none';
                };
                img.onload = function() {
                    console.log(`Successfully loaded FFZ emote: ${name}`);
                };
                
                emoteElement.appendChild(img);
                emoteElement.addEventListener('click', () => {
                    insertEmote(name);
                    // Don't hide picker - let user select multiple emotes
                });
                ffzEmoteGrid.appendChild(emoteElement);
            });
        }

        function initializeFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            currentChannel = urlParams.get('channel') || urlParams.get('stream') || 'general';
            const providedUsername = urlParams.get('username') || urlParams.get('user') || urlParams.get('nick');
            
            channelName.textContent = `#${currentChannel}`;
            if (providedUsername && providedUsername.trim().length >= 2) {
                currentUser = providedUsername.trim();
                usernameSetup.classList.remove('show');
                chatContainer.style.display = 'flex';
                if (socket.connected) {
                    joinChannel();
                }
            } else {
                usernameInput.value = generateRandomUsername();
                usernameSetup.classList.add('show');
                chatContainer.style.display = 'none';
                usernameInput.focus();
            }
            initializeEmojiPicker();
        }
        
        function initializeEmojiPicker() {
            // Initialize basic emojis
            emoteGrid.innerHTML = '';
            basicEmojis.forEach(emoji => {
                const emoteElement = document.createElement('button');
                emoteElement.className = 'emote-item';
                emoteElement.innerHTML = twemoji.parse(emoji);
                emoteElement.dataset.emoji = emoji;
                emoteElement.addEventListener('click', () => {
                    insertEmote(emoji);
                    // Don't hide picker - let user select multiple emotes
                });
                emoteGrid.appendChild(emoteElement);
            });
            
            // Initialize FFZ emotes
            loadFFZEmotes();
            
            // FFZ search functionality
            let searchTimeout;
            ffzSearch.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    ffzSearchTerm = e.target.value.trim();
                    ffzPage = 1;
                    loadFFZEmotes(ffzSearchTerm, ffzPage, false);
                }, 300);
            });
            
            // FFZ load more
            ffzLoadMore.addEventListener('click', () => {
                ffzPage++;
                loadFFZEmotes(ffzSearchTerm, ffzPage, true);
            });
            
            document.querySelectorAll('.emote-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    switchEmoteTab(tab.dataset.tab);
                });
            });
        }
        
        function switchEmoteTab(tabName) {
            currentTab = tabName;
            document.querySelectorAll('.emote-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });
            document.getElementById('emojiGrid').style.display = tabName === 'emoji' ? 'grid' : 'none';
            document.getElementById('ffzGrid').style.display = tabName === 'ffz' ? 'block' : 'none';
            
            // Focus search when FFZ tab is opened
            if (tabName === 'ffz') {
                setTimeout(() => ffzSearch.focus(), 100);
            }
        }
        
        function insertEmote(emote) {
            const cursorPos = messageInput.selectionStart;
            const textBefore = messageInput.value.substring(0, cursorPos);
            const textAfter = messageInput.value.substring(cursorPos);
            
            // Add space before emote if needed (not at beginning and no space before)
            const spaceBefore = (textBefore.length > 0 && !textBefore.endsWith(' ')) ? ' ' : '';
            // Always add space after emote
            const spaceAfter = ' ';
            
            messageInput.value = textBefore + spaceBefore + emote + spaceAfter + textAfter;
            messageInput.focus();
            const newCursorPos = cursorPos + spaceBefore.length + emote.length + spaceAfter.length;
            messageInput.setSelectionRange(newCursorPos, newCursorPos);
            
            // Remove the required attribute temporarily to allow building message
            messageInput.removeAttribute('required');
        }
        
        function showEmotePicker() { emotePicker.classList.add('show'); }
        function hideEmotePicker() { emotePicker.classList.remove('show'); }
        
        function setUsername() {
            const username = usernameInput.value.trim();
            if (!username || username.length < 2) { showError('Username must be at least 2 characters'); return; }
            if (username.length > 20) { showError('Username is too long (max 20 characters)'); return; }
            currentUser = username;
            usernameSetup.classList.remove('show');
            chatContainer.style.display = 'flex';
            joinChannel();
        }
        
        function joinChannel() {
            if (!currentUser || !currentChannel || !socket.connected) return;
            socket.emit('join-channel', { username: currentUser, channel: currentChannel });
        }
        
        function setReply(username, messageContent) {
            currentReply = { username: username, messageContent: messageContent };
            replyContent.innerHTML = 'Replying to <strong class="' + getUserColor(username) + '">' + escapeHtml(username) + '</strong>: ' + escapeHtml(messageContent.substring(0, 50)) + (messageContent.length > 50 ? '...' : '');
            replyPreview.style.display = 'block';
            messageInput.focus();
        }
        
        function cancelReplyFunc() {
            currentReply = null;
            replyPreview.style.display = 'none';
        }
        
        function sendMessage() {
            const message = messageInput.value.trim();
            if (!message || !currentUser) return;
            if (!socket.connected) { showError('Not connected to chat server'); return; }
            
            // Re-add required attribute for next message
            messageInput.setAttribute('required', 'required');
            
            const messageData = { message };
            if (currentReply) {
                messageData.replyTo = currentReply;
            }
            
            socket.emit('send-message', messageData);
            messageInput.value = '';
            cancelReplyFunc();
            stopTyping();
        }

        function escapeHtml(text) { 
            const div = document.createElement('div'); 
            div.textContent = text; 
            return div.innerHTML; 
        }

        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function processEmotes(text) {
            let processedText = escapeHtml(text);

            // Process FFZ emotes (both popular and any loaded via API)
            const allFFZEmotes = { ...popularFFZEmotes, ...ffzEmotes };
            Object.keys(allFFZEmotes).forEach(emoteName => {
                const regex = new RegExp(`\\b${escapeRegex(emoteName)}\\b`, 'g');
                processedText = processedText.replace(regex, 
                    `<img src="${allFFZEmotes[emoteName]}" alt="${emoteName}" class="ffz-emote-inline" title="${emoteName}">`
                );
            });
            
            return twemoji.parse(processedText, {
                className: 'emote', folder: 'svg', ext: '.svg'
            });
        }
        
        // Event listeners
        setUsernameBtn.addEventListener('click', setUsername);
        usernameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') setUsername(); });
        messageForm.addEventListener('submit', (e) => { e.preventDefault(); sendMessage(); });
        emoteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            emotePicker.classList.toggle('show');
        });
        cancelReply.addEventListener('click', cancelReplyFunc);
        
        document.addEventListener('click', (e) => {
            if (!emotePicker.contains(e.target) && e.target !== emoteBtn) {
                hideEmotePicker();
            }
        });
        
        messageInput.addEventListener('input', () => {
            if (!currentUser) return;
            if (!isTyping) { 
                isTyping = true; 
                socket.emit('typing', { isTyping: true }); 
            }
            clearTimeout(typingTimer);
            typingTimer = setTimeout(stopTyping, 1500);
        });
        
        function stopTyping() {
            if (currentUser && isTyping) { 
                isTyping = false; 
                socket.emit('typing', { isTyping: false }); 
            }
        }
        
        // Socket event listeners
        socket.on('connect', () => { if (currentUser && currentChannel) joinChannel(); });
        socket.on('disconnect', () => { addSystemMessage('Disconnected. Reconnecting...'); });
        socket.on('connect_error', () => { showError('Connection failed. Please refresh.'); });
        socket.on('joined-channel', (data) => { 
            addSystemMessage('Welcome to #' + data.channel + '!'); 
            messageInput.focus(); 
        });
        socket.on('channel-info', (data) => { updateChannelInfo(data); });
        socket.on('user-joined', (data) => { 
            addSystemMessage(data.username + ' joined'); 
            updateChannelInfo(data); 
        });
        socket.on('user-left', (data) => { 
            addSystemMessage(data.username + ' left'); 
            updateChannelInfo(data); 
        });
        socket.on('new-message', (data) => { addMessage(data); });
        socket.on('user-typing', (data) => {
            const typingUsers = Object.keys(data.typingUsers).filter(u => u !== currentUser);
            if (typingUsers.length === 0) { 
                typingIndicator.textContent = ''; 
            } else if (typingUsers.length === 1) { 
                typingIndicator.textContent = typingUsers[0] + ' is typing...'; 
            } else { 
                typingIndicator.textContent = typingUsers.length + ' people are typing...'; 
            }
        });
        socket.on('error', (data) => { showError(data.message); });
        
        function showError(message) { 
            errorContainer.innerHTML = `<div class="error">${escapeHtml(message)}</div>`; 
            setTimeout(() => { errorContainer.innerHTML = ''; }, 5000); 
        }
        
        function addMessage(data) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.dataset.username = data.username;
            
            const time = new Date(data.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            const userColor = getUserColor(data.username);
            
            let messageHTML = '';
            
            if (data.replyTo) {
                const replyColor = getUserColor(data.replyTo.username);
                messageHTML += `<div class="reply-indicator">@Replying to <span class="${replyColor}">${escapeHtml(data.replyTo.username)}</span></div>`;
                messageDiv.classList.add('reply');
            }
            
            messageHTML += `<div class="message-header">
                <span class="message-username ${userColor}">${escapeHtml(data.username)}</span>
                <span class="message-time">${time}</span>
                </div>
                <div class="message-content">${processEmotes(data.message)}</div>`;
            
            messageDiv.innerHTML = messageHTML;
            
            if (data.username !== currentUser) {
                messageDiv.addEventListener('click', () => {
                    setReply(data.username, data.message);
                });
            }
            
            const wasScrolledToBottom = messages.scrollHeight - messages.clientHeight <= messages.scrollTop + 1;
            messages.appendChild(messageDiv);
            if (wasScrolledToBottom) {
                scrollToBottom();
            }
        }
        
        function addSystemMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message system';
            messageDiv.textContent = message;
            messages.appendChild(messageDiv);
            scrollToBottom();
        }
        
        function updateChannelInfo(data) { 
            const count = data.userCount || 0; 
            userCount.textContent = `${count} viewer${(count !== 1 ? 's' : '')}`; 
        }
        
        function scrollToBottom() { 
            messages.scrollTop = messages.scrollHeight; 
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            try { 
                initializeFromURL(); 
                addSystemMessage('Connecting to chat...'); 
            }
            catch (error) { 
                console.error('Initialization Error:', error); 
                showError('Failed to initialize chat'); 
            }
        });
    </script>
</body>
</html>
