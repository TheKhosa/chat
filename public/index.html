<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Chat</title>
    <script src="/socket.io/socket.io.js"></script>
    <!-- Replaced emoji-js with Twemoji for better emoji rendering and support -->
    <script src="https://cdn.jsdelivr.net/npm/twemoji@latest/dist/twemoji.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background: #1a1a1a; color: #e5e5e5; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        .container { width: 100%; height: 100vh; background: #1a1a1a; display: flex; flex-direction: column; border: none; }
        .header { background: #0a0a0a; color: #e5e5e5; padding: 12px 16px; border-bottom: 1px solid #2c2c2c; display: flex; align-items: center; justify-content: space-between; min-height: 50px; }
        .header h1 { font-size: 1rem; font-weight: 600; color: #e5e5e5; }
        .channel-info { background: #0f0f0f; padding: 8px 16px; border-bottom: 1px solid #2c2c2c; font-size: 12px; color: #8a8a8a; display: flex; justify-content: space-between; align-items: center; }
        .username-setup { background: #0f0f0f; padding: 12px 16px; border-bottom: 1px solid #2c2c2c; display: none; }
        .username-setup.show { display: flex; align-items: center; gap: 8px; }
        .username-setup input { flex: 1; padding: 6px 8px; border: 1px solid #2c2c2c; border-radius: 4px; background: #1a1a1a; color: #e5e5e5; font-size: 12px; }
        .username-setup input:focus { outline: none; border-color: #c02b2b; }
        .username-setup button { background: #c02b2b; color: white; padding: 6px 12px; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; transition: background 0.2s; }
        .username-setup button:hover { background: #e04141; }
        .chat-container { display: flex; flex: 1; flex-direction: column; overflow: hidden; }
        .messages { flex: 1; overflow-y: auto; padding: 8px; background: #1a1a1a; scrollbar-width: thin; scrollbar-color: #2c2c2c #1a1a1a; }
        .messages::-webkit-scrollbar { width: 6px; }
        .messages::-webkit-scrollbar-track { background: #1a1a1a; }
        .messages::-webkit-scrollbar-thumb { background: #2c2c2c; border-radius: 3px; }
        .message { margin-bottom: 8px; padding: 6px 8px; border-radius: 4px; background: rgba(255, 255, 255, 0.03); font-size: 13px; line-height: 1.4; word-wrap: break-word; cursor: pointer; transition: background 0.2s; position: relative; }
        .message:hover { background: rgba(255, 255, 255, 0.06); }
        .message.system { background: rgba(192, 43, 43, 0.1); color: #ff6b6b; font-style: italic; text-align: center; font-size: 12px; cursor: default; }
        .message.system:hover { background: rgba(192, 43, 43, 0.1); }
        .message.reply { background: rgba(192, 43, 43, 0.08); border-left: 3px solid #c02b2b; }
        .message-header { font-weight: 600; margin-bottom: 2px; font-size: 12px; display: flex; align-items: center; gap: 6px; }
        .message-username { cursor: pointer; }
        .message-username:hover { text-decoration: underline; }
        .message-time { font-size: 10px; color: #666; margin-left: auto; }
        .reply-indicator { background: rgba(192, 43, 43, 0.2); color: #ff8a8a; font-size: 10px; padding: 2px 6px; border-radius: 3px; margin-bottom: 4px; border-left: 2px solid #c02b2b; }
        .message-content { color: #e5e5e5; line-height: 1.4; }
        .typing-indicator { padding: 6px 16px; font-style: italic; color: #8a8a8a; font-size: 11px; min-height: 24px; background: #0f0f0f; border-top: 1px solid #2c2c2c; }
        .message-form { 
            display: flex; 
            padding: 8px; 
            background: #0f0f0f; 
            border-top: 1px solid #2c2c2c; 
            gap: 8px; 
            flex-direction: column; 
            position: relative; /* <-- FIX: This is the crucial fix. It anchors the absolute-positioned emote picker. */
        }
        .reply-preview { background: rgba(192, 43, 43, 0.1); border-left: 3px solid #c02b2b; padding: 6px 8px; font-size: 11px; color: #ccc; margin-bottom: 8px; border-radius: 3px; display: none; position: relative; }
        .reply-preview .cancel-reply { position: absolute; top: 4px; right: 6px; background: none; border: none; color: #999; cursor: pointer; font-size: 14px; padding: 0; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; }
        .reply-preview .cancel-reply:hover { color: #fff; }
        .message-input-row { display: flex; gap: 8px; }
        .message-input { flex: 1; padding: 8px; border: 1px solid #2c2c2c; border-radius: 4px; font-size: 13px; background: #1a1a1a; color: #e5e5e5; }
        .message-input:focus { outline: none; border-color: #c02b2b; }
        .emote-btn { background: #2c2c2c; color: #e5e5e5; padding: 8px 10px; border: none; border-radius: 4px; cursor: pointer; transition: background 0.2s; font-size: 12px; }
        .emote-btn:hover { background: #3c3c3c; }
        .send-btn { background: #c02b2b; color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; transition: background 0.2s; font-size: 12px; }
        .send-btn:hover { background: #e04141; }
        .emote-picker { position: absolute; bottom: 100%; right: 8px; /* Adjusted right positioning to align better */ background: #0f0f0f; border: 1px solid #2c2c2c; border-radius: 6px; display: none; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); width: 320px; max-height: 300px; overflow-y: auto; margin-bottom: 8px; /* Added margin */ }
        .emote-picker.show { display: block; }
        .emote-tabs { display: flex; border-bottom: 1px solid #2c2c2c; background: #0a0a0a; }
        .emote-tab { flex: 1; padding: 8px 12px; background: none; border: none; color: #8a8a8a; cursor: pointer; font-size: 11px; transition: all 0.2s; }
        .emote-tab.active { color: #c02b2b; background: #1a1a1a; }
        .emote-tab:hover { background: rgba(255, 255, 255, 0.05); }
        .emote-content { padding: 8px; max-height: 240px; overflow-y: auto; }
        .emote-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; }
        .emote-item { background: none; border: none; padding: 6px; border-radius: 4px; cursor: pointer; font-size: 18px; transition: background 0.2s; display: flex; align-items: center; justify-content: center; min-height: 32px; }
        .emote-item:hover { background: rgba(255, 255, 255, 0.1); }
        .emote-item img { width: 24px; height: 24px; object-fit: contain; }
        .error { color: #ff6b6b; background: rgba(255, 107, 107, 0.1); padding: 8px; border-radius: 4px; margin: 8px; text-align: center; font-size: 12px; }
        body::-webkit-scrollbar { display: none; }
        body { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* User Color Classes */
        .user-red { color: #ff6b6b !important; } .user-orange { color: #ffa726 !important; } .user-yellow { color: #ffeb3b !important; } .user-green { color: #66bb6a !important; } .user-blue { color: #42a5f5 !important; } .user-purple { color: #ab47bc !important; } .user-pink { color: #ec407a !important; } .user-cyan { color: #26c6da !important; } .user-lime { color: #9ccc65 !important; } .user-indigo { color: #5c6bc0 !important; } .user-teal { color: #26a69a !important; } .user-amber { color: #ffca28 !important; }
        
        /* Emote styling in messages */
        /* This class is now used by Twemoji's output */
        .emote {
            height: 1.5em;
            width: 1.5em;
            vertical-align: middle;
            margin: 0 2px;
        }
        .custom-emote {
            height: 24px;
            vertical-align: middle;
            margin: 0 2px;
        }
        .gif-emote {
            height: 32px;
            vertical-align: middle;
            margin: 0 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="usernameSetup" class="username-setup">
            <input type="text" id="usernameInput" placeholder="Enter your username..." maxlength="20">
            <button id="setUsernameBtn">Set Username</button>
        </div>
        <div id="errorContainer"></div>
        <div id="chatContainer" class="chat-container" style="display: none;">
            <div class="channel-info">
                <div id="channelName"></div>
                <div id="userCount"></div>
            </div>
            <div id="messages" class="messages"></div>
            <div id="typingIndicator" class="typing-indicator"></div>
            <form id="messageForm" class="message-form">
                <div id="replyPreview" class="reply-preview">
                    <button type="button" class="cancel-reply" id="cancelReply">Ã—</button>
                    <div id="replyContent"></div>
                </div>
                <div class="message-input-row">
                    <input type="text" id="messageInput" class="message-input" placeholder="Type your message..." maxlength="500" required>
                    <button type="button" id="emoteBtn" class="emote-btn">ğŸ˜€</button>
                    <button type="submit" class="send-btn">Send</button>
                </div>
                <div id="emotePicker" class="emote-picker">
                    <div class="emote-tabs">
                        <button class="emote-tab active" data-tab="emoji">ğŸ˜€ Emoji</button>
                        <button class="emote-tab" data-tab="custom">ğŸ® Custom</button>
                        <button class="emote-tab" data-tab="gifs">ğŸ¬ GIFs</button>
                    </div>
                    <div class="emote-content">
                        <div id="emojiGrid" class="emote-grid"></div>
                        <div id="customGrid" class="emote-grid" style="display: none;"></div>
                        <div id="gifsGrid" class="emote-grid" style="display: none;"></div>
                    </div>
                </div>
            </form>
        </div>
    </div>
    <script>
        var socket = io();
        var currentUser = null;
        var currentChannel = null;
        var typingTimer = null;
        var currentReply = null;
        var userColors = {};
        
        // DOM elements
        var channelName = document.getElementById('channelName');
        var userCount = document.getElementById('userCount');
        var usernameSetup = document.getElementById('usernameSetup');
        var usernameInput = document.getElementById('usernameInput');
        var setUsernameBtn = document.getElementById('setUsernameBtn');
        var chatContainer = document.getElementById('chatContainer');
        var messages = document.getElementById('messages');
        var messageForm = document.getElementById('messageForm');
        var messageInput = document.getElementById('messageInput');
        var typingIndicator = document.getElementById('typingIndicator');
        var errorContainer = document.getElementById('errorContainer');
        var emoteBtn = document.getElementById('emoteBtn');
        var emotePicker = document.getElementById('emotePicker');
        var emoteGrid = document.getElementById('emojiGrid');
        var customGrid = document.getElementById('customGrid');
        var gifsGrid = document.getElementById('gifsGrid');
        var replyPreview = document.getElementById('replyPreview');
        var replyContent = document.getElementById('replyContent');
        var cancelReply = document.getElementById('cancelReply');
        
        // Custom emotes and GIFs configuration
        var customEmotes = {
            'Kappa': 'https://static-cdn.jtvnw.net/emoticons/v2/25/default/dark/1.0',
            'PogChamp': 'https://static-cdn.jtvnw.net/emoticons/v2/88/default/dark/1.0',
            'KEKW': 'https://cdn.7tv.app/emote/60a57218eca3e55c5e6e9cd3/1x.webp',
            'LUL': 'https://static-cdn.jtvnw.net/emoticons/v2/425618/default/dark/1.0',
            'MonkaS': 'https://cdn.7tv.app/emote/60a57218eca3e55c5e6e9cd0/1x.webp',
            'EZ': 'https://cdn.7tv.app/emote/60a5722dec18e05c5e6e9cdf/1x.webp'
        };
        
        var gifEmotes = {
            'PepeParty': 'https://cdn.7tv.app/emote/60b07b34a632b9b67b3f4862/1x.gif',
            'CatJAM': 'https://cdn.7tv.app/emote/60b07b34a632b9b67b3f4851/1x.gif',
            'EzDance': 'https://cdn.7tv.app/emote/60b07b34a632b9b67b3f485f/1x.gif',
            'PartyParrot': 'https://cdn.7tv.app/emote/60b07b34a632b9b67b3f4865/1x.gif'
        };
        
        // Basic emoji collection
        var basicEmojis = [
            'ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ¤£', 'ğŸ˜‚', 'ğŸ™‚', 'ğŸ™ƒ',
            'ğŸ˜‰', 'ğŸ˜Š', 'ğŸ˜‡', 'ğŸ¥°', 'ğŸ˜', 'ğŸ¤©', 'ğŸ˜˜', 'ğŸ˜—', 'â˜ºï¸', 'ğŸ˜š',
            'ğŸ˜™', 'ğŸ¥²', 'ğŸ˜‹', 'ğŸ˜›', 'ğŸ˜œ', 'ğŸ¤ª', 'ğŸ˜', 'ğŸ¤‘', 'ğŸ¤—', 'ğŸ¤­',
            'ğŸ¤«', 'ğŸ¤”', 'ğŸ¤', 'ğŸ¤¨', 'ğŸ˜', 'ğŸ˜‘', 'ğŸ˜¶', 'ğŸ˜', 'ğŸ˜’', 'ğŸ™„',
            'ğŸ˜¬', 'ğŸ¤¥', 'ğŸ˜”', 'ğŸ˜ª', 'ğŸ¤¤', 'ğŸ˜´', 'ğŸ˜·', 'ğŸ¤’', 'ğŸ¤•', 'ğŸ¤¢',
            'ğŸ¤®', 'ğŸ¤§', 'ğŸ¥µ', 'ğŸ¥¶', 'ğŸ¥´', 'ğŸ˜µ', 'ğŸ¤¯', 'ğŸ¤ ', 'ğŸ¥³', 'ğŸ¥¸',
            'ğŸ˜', 'ğŸ¤“', 'ğŸ§', 'ğŸ˜•', 'ğŸ˜Ÿ', 'ğŸ™', 'â˜¹ï¸', 'ğŸ˜®', 'ğŸ˜¯', 'ğŸ˜²',
            'ğŸ˜³', 'ğŸ¥º', 'ğŸ˜¦', 'ğŸ˜§', 'ğŸ˜¨', 'ğŸ˜°', 'ğŸ˜¥', 'ğŸ˜¢', 'ğŸ˜­', 'ğŸ˜±',
            'ğŸ˜–', 'ğŸ˜£', 'ğŸ˜', 'ğŸ˜“', 'ğŸ˜©', 'ğŸ˜«', 'ğŸ¥±', 'ğŸ˜¤', 'ğŸ˜¡', 'ğŸ˜ ',
            'ğŸ¤¬', 'ğŸ˜ˆ', 'ğŸ‘¿', 'ğŸ’€', 'â˜ ï¸', 'ğŸ’©', 'ğŸ¤¡', 'ğŸ‘¹', 'ğŸ‘º', 'ğŸ‘»',
            'ğŸ‘½', 'ğŸ‘¾', 'ğŸ¤–', 'ğŸƒ', 'â¤ï¸', 'ğŸ§¡', 'ğŸ’›', 'ğŸ’š', 'ğŸ’™', 'ğŸ’œ',
            'ğŸ–¤', 'ğŸ¤', 'ğŸ¤', 'ğŸ’”', 'â£ï¸', 'ğŸ’•', 'ğŸ’', 'ğŸ’“', 'ğŸ’—', 'ğŸ’–',
            'ğŸ’˜', 'ğŸ’', 'ğŸ’Ÿ', 'ğŸ‘', 'ğŸ‘', 'ğŸ‘Œ', 'ğŸ¤', 'âœŒï¸', 'ğŸ¤', 'ğŸ¤Ÿ',
            'ğŸ¤˜', 'ğŸ¤™', 'ğŸ‘ˆ', 'ğŸ‘‰', 'ğŸ‘†', 'ğŸ‘‡', 'â˜ï¸', 'ğŸ‘‹', 'ğŸ¤š', 'ğŸ–ï¸',
            'âœ‹', 'ğŸ––', 'ğŸ‘', 'ğŸ™Œ', 'ğŸ‘', 'ğŸ¤²', 'ğŸ¤', 'ğŸ™', 'âœï¸', 'ğŸ’ª',
            'ğŸ”¥', 'ğŸ’¯', 'ğŸ’', 'âš¡', 'ğŸŒŸ', 'âœ¨', 'ğŸ‰', 'ğŸŠ', 'ğŸ†', 'ğŸ¯'
        ];
        
        var currentTab = 'emoji';
        var isTyping = false;
        
        // User color classes
        const colorClasses = [
            'user-red', 'user-orange', 'user-yellow', 'user-green',
            'user-blue', 'user-purple', 'user-pink', 'user-cyan',
            'user-lime', 'user-indigo', 'user-teal', 'user-amber'
        ];
        
        function generateRandomUsername() {
            const adjectives = ['Happy', 'Cool', 'Swift', 'Bright', 'Silent', 'Bold'];
            const nouns = ['Viewer', 'User', 'Guest', 'Watcher', 'Fan', 'Friend'];
            const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            const number = Math.floor(Math.random() * 999) + 1;
            return `${adj}${noun}${number}`;
        }
        
        function getUserColor(username) {
            if (!userColors[username]) {
                let hash = 0;
                for (let i = 0; i < username.length; i++) {
                    hash = username.charCodeAt(i) + ((hash << 5) - hash);
                }
                userColors[username] = colorClasses[Math.abs(hash) % colorClasses.length];
            }
            return userColors[username];
        }
        
        function initializeFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            currentChannel = urlParams.get('channel') || urlParams.get('stream') || 'general';
            const providedUsername = urlParams.get('username') || urlParams.get('user') || urlParams.get('nick');
            
            channelName.textContent = `#${currentChannel}`;
            if (providedUsername && providedUsername.trim().length >= 2) {
                currentUser = providedUsername.trim();
                usernameSetup.classList.remove('show');
                chatContainer.style.display = 'flex';
                if (socket.connected) {
                    joinChannel();
                }
            } else {
                usernameInput.value = generateRandomUsername();
                usernameSetup.classList.add('show');
                chatContainer.style.display = 'none';
                usernameInput.focus();
            }
            initializeEmojiPicker();
        }
        
        function initializeEmojiPicker() {
            emoteGrid.innerHTML = '';
            basicEmojis.forEach(emoji => {
                const emoteElement = document.createElement('button');
                emoteElement.className = 'emote-item';
                emoteElement.innerHTML = twemoji.parse(emoji);
                emoteElement.dataset.emoji = emoji;
                emoteElement.addEventListener('click', () => {
                    insertEmoji(emoji);
                    hideEmotePicker();
                });
                emoteGrid.appendChild(emoteElement);
            });
            
            customGrid.innerHTML = '';
            Object.keys(customEmotes).forEach(emoteName => {
                const emoteElement = document.createElement('button');
                emoteElement.className = 'emote-item';
                emoteElement.innerHTML = `<img src="${customEmotes[emoteName]}" alt="${emoteName}" title="${emoteName}">`;
                emoteElement.addEventListener('click', () => {
                    insertEmoji(`:${emoteName}:`);
                    hideEmotePicker();
                });
                customGrid.appendChild(emoteElement);
            });
            
            gifsGrid.innerHTML = '';
            Object.keys(gifEmotes).forEach(emoteName => {
                const emoteElement = document.createElement('button');
                emoteElement.className = 'emote-item';
                emoteElement.innerHTML = `<img src="${gifEmotes[emoteName]}" alt="${emoteName}" title="${emoteName}">`;
                emoteElement.addEventListener('click', () => {
                    insertEmoji(`:${emoteName}:`);
                    hideEmotePicker();
                });
                gifsGrid.appendChild(emoteElement);
            });
            
            document.querySelectorAll('.emote-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    switchEmoteTab(tab.dataset.tab);
                });
            });
        }
        
        function switchEmoteTab(tabName) {
            currentTab = tabName;
            document.querySelectorAll('.emote-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });
            document.getElementById('emojiGrid').style.display = tabName === 'emoji' ? 'grid' : 'none';
            document.getElementById('customGrid').style.display = tabName === 'custom' ? 'grid' : 'none';
            document.getElementById('gifsGrid').style.display = tabName === 'gifs' ? 'grid' : 'none';
        }
        
        function insertEmoji(emoji) {
            const cursorPos = messageInput.selectionStart;
            const textBefore = messageInput.value.substring(0, cursorPos);
            const textAfter = messageInput.value.substring(cursorPos);
            
            messageInput.value = textBefore + emoji + " " + textAfter;
            messageInput.focus();
            const newCursorPos = cursorPos + emoji.length + 1;
            messageInput.setSelectionRange(newCursorPos, newCursorPos);
        }
        
        function showEmotePicker() { emotePicker.classList.add('show'); }
        function hideEmotePicker() { emotePicker.classList.remove('show'); }
        
        function setUsername() {
            const username = usernameInput.value.trim();
            if (!username || username.length < 2) { showError('Username must be at least 2 characters'); return; }
            if (username.length > 20) { showError('Username is too long (max 20 characters)'); return; }
            currentUser = username;
            usernameSetup.classList.remove('show');
            chatContainer.style.display = 'flex';
            joinChannel();
        }
        
        function joinChannel() {
            if (!currentUser || !currentChannel || !socket.connected) return;
            socket.emit('join-channel', { username: currentUser, channel: currentChannel });
        }
        
        function setReply(username, messageContent) {
            currentReply = { username: username, messageContent: messageContent };
            replyContent.innerHTML = 'Replying to <strong class="' + getUserColor(username) + '">' + escapeHtml(username) + '</strong>: ' + escapeHtml(messageContent.substring(0, 50)) + (messageContent.length > 50 ? '...' : '');
            replyPreview.style.display = 'block';
            messageInput.focus();
        }
        
        function cancelReplyFunc() {
            currentReply = null;
            replyPreview.style.display = 'none';
        }
        
        function sendMessage() {
            const message = messageInput.value.trim();
            if (!message || !currentUser) return;
            if (!socket.connected) { showError('Not connected to chat server'); return; }
            
            const messageData = { message };
            if (currentReply) {
                messageData.replyTo = currentReply;
            }
            
            socket.emit('send-message', messageData);
            messageInput.value = '';
            cancelReplyFunc();
            stopTyping();
        }

        function escapeHtml(text) { 
            const div = document.createElement('div'); 
            div.textContent = text; 
            return div.innerHTML; 
        }

        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function processEmotes(text) {
            // 1. Escape the entire message first to prevent any XSS attacks.
            let processedText = escapeHtml(text);

            // 2. Replace custom emote codes with their image tags.
            Object.keys(customEmotes).forEach(emoteName => {
                const regex = new RegExp(escapeRegex(`:${emoteName}:`), 'g');
                processedText = processedText.replace(regex, 
                    `<img src="${customEmotes[emoteName]}" alt="${emoteName}" class="custom-emote" title="${emoteName}">`
                );
            });

            // 3. Replace GIF emote codes with their image tags.
            Object.keys(gifEmotes).forEach(emoteName => {
                const regex = new RegExp(escapeRegex(`:${emoteName}:`), 'g');
                processedText = processedText.replace(regex, 
                    `<img src="${gifEmotes[emoteName]}" alt="${emoteName}" class="gif-emote" title="${emoteName}">`
                );
            });
            
            // 4. Use Twemoji to parse all standard Unicode emojis and convert them to images.
            // This ensures they render correctly everywhere and don't break the HTML.
            return twemoji.parse(processedText, {
                className: 'emote', // Use our custom class for styling
                folder: 'svg',      // Use SVG for crisp, scalable emojis
                ext: '.svg'
            });
        }
        
        // Event listeners
        setUsernameBtn.addEventListener('click', setUsername);
        usernameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') setUsername(); });
        messageForm.addEventListener('submit', (e) => { e.preventDefault(); sendMessage(); });
        emoteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            emotePicker.classList.toggle('show');
        });
        cancelReply.addEventListener('click', cancelReplyFunc);
        
        document.addEventListener('click', (e) => {
            if (!emotePicker.contains(e.target) && e.target !== emoteBtn) {
                hideEmotePicker();
            }
        });
        
        messageInput.addEventListener('input', () => {
            if (!currentUser) return;
            if (!isTyping) { 
                isTyping = true; 
                socket.emit('typing', { isTyping: true }); 
            }
            clearTimeout(typingTimer);
            typingTimer = setTimeout(stopTyping, 1500);
        });
        
        function stopTyping() {
            if (currentUser && isTyping) { 
                isTyping = false; 
                socket.emit('typing', { isTyping: false }); 
            }
        }
        
        // Socket event listeners
        socket.on('connect', () => { if (currentUser && currentChannel) joinChannel(); });
        socket.on('disconnect', () => { addSystemMessage('Disconnected. Reconnecting...'); });
        socket.on('connect_error', () => { showError('Connection failed. Please refresh.'); });
        socket.on('joined-channel', (data) => { 
            addSystemMessage('Welcome to #' + data.channel + '!'); 
            messageInput.focus(); 
        });
        socket.on('channel-info', (data) => { updateChannelInfo(data); });
        socket.on('user-joined', (data) => { 
            addSystemMessage(data.username + ' joined'); 
            updateChannelInfo(data); 
        });
        socket.on('user-left', (data) => { 
            addSystemMessage(data.username + ' left'); 
            updateChannelInfo(data); 
        });
        socket.on('new-message', (data) => { addMessage(data); });
        socket.on('user-typing', (data) => {
            const typingUsers = Object.keys(data.typingUsers).filter(u => u !== currentUser);
            if (typingUsers.length === 0) { 
                typingIndicator.textContent = ''; 
            } else if (typingUsers.length === 1) { 
                typingIndicator.textContent = typingUsers[0] + ' is typing...'; 
            } else { 
                typingIndicator.textContent = typingUsers.length + ' people are typing...'; 
            }
        });
        socket.on('error', (data) => { showError(data.message); });
        
        function showError(message) { 
            errorContainer.innerHTML = `<div class="error">${escapeHtml(message)}</div>`; 
            setTimeout(() => { errorContainer.innerHTML = ''; }, 5000); 
        }
        
        function addMessage(data) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.dataset.username = data.username;
            
            const time = new Date(data.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            const userColor = getUserColor(data.username);
            
            let messageHTML = '';
            
            if (data.replyTo) {
                const replyColor = getUserColor(data.replyTo.username);
                messageHTML += `<div class="reply-indicator">@Replying to <span class="${replyColor}">${escapeHtml(data.replyTo.username)}</span></div>`;
                messageDiv.classList.add('reply');
            }
            
            // The processEmotes function now handles all escaping and conversions.
            messageHTML += `<div class="message-header">
                <span class="message-username ${userColor}">${escapeHtml(data.username)}</span>
                <span class="message-time">${time}</span>
                </div>
                <div class="message-content">${processEmotes(data.message)}</div>`;
            
            messageDiv.innerHTML = messageHTML;
            
            if (data.username !== currentUser) {
                messageDiv.addEventListener('click', () => {
                    setReply(data.username, data.message);
                });
            }
            
            const wasScrolledToBottom = messages.scrollHeight - messages.clientHeight <= messages.scrollTop + 1;
            messages.appendChild(messageDiv);
            if (wasScrolledToBottom) {
                scrollToBottom();
            }
        }
        
        function addSystemMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message system';
            messageDiv.textContent = message;
            messages.appendChild(messageDiv);
            scrollToBottom();
        }
        
        function updateChannelInfo(data) { 
            const count = data.userCount || 0; 
            userCount.textContent = `${count} viewer${(count !== 1 ? 's' : '')}`; 
        }
        
        function scrollToBottom() { 
            messages.scrollTop = messages.scrollHeight; 
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            try { 
                initializeFromURL(); 
                addSystemMessage('Connecting to chat...'); 
            }
            catch (error) { 
                console.error('Initialization Error:', error); 
                showError('Failed to initialize chat'); 
            }
        });
    </script>
</body>
</html>
